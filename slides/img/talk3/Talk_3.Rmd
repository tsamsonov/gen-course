---
title: "Картографические базы данных"
author: "Тимофей Самсонов"
date: "`r Sys.Date()`"
output:
 ioslides_presentation:
   widescreen: yes
   variant: markdown+link_attributes
  # xaringan::moon_reader:
  #   css: [default, metropolis, metropolis-fonts]
---

## Генерализация множеств точечных объектов

Картографические базы данных. Лекция 3

**Тимофей Самсонов**
[tsamsonov@geogr.msu.ru](tsamsonov@geogr.msu.ru)



## Генерализация множеств точечных объектов

**Методы генерализации**

1. Регионизация
1. Отбор
1. Кластеризация

**Аспекты**

1. Вспомогательные геометрические структуры
1. Параметризация алгоритмов
1. Оценка результатов



## Триангуляция Делоне и диаграмма Вороного

**Триангуляция** (на плоскости) — это разбиение фигуры на треугольники.

<div style="display: inline-block; width: 65%; vertical-align: top;">

- Треугольники покрывают всю фигуру без «дыр», при этом они либо не пересекаются, либо касаются в точке или вершине.

- Под триангуляцией множества точек понимается *триангуляция их выпуклой оболочки*, в которой сами точки являются вершинами треугольников.

- В *триангуляции Делоне* окружность, описанная вокруг каждого треугольника, не содержит других точек этого множества

</div>

<div style="display: inline-block; width: 30%; vertical-align: top; margin-left: 2%">
  ![](tin.svg){width=200px}
</div>

**Delaunay, Boris** (1934). *Sur la sphère vide*. Bulletin de l'Académie des Sciences de l'URSS, Classe des sciences mathématiques et naturelles. 6: 793–800.

## Триангуляция Делоне и диаграмма Вороного

**Диаграмма Вороного** конечного множества точек $S$ на плоскости представляет такое разбиение плоскости, при котором каждая область этого разбиения образует множество точек, более близких к одному из элементов множества $S$, чем к любому другому элементу множества.

<div style="display: inline-block; width: 55%; vertical-align: top;">

- Другие названия диаграммы — *полигоны Тиссена*, *разбиение Дирихле*

- Диаграмма Вороного строится на основе серединных перпендикуляров к сторонам треугольников

- Диаграмма Вороного множества точек взаимно однозначна триангуляции Делоне множества точек

</div>

<div style="display: inline-block; width: 40%; vertical-align: top; margin-left: 2%">
  <img src="voronoi.svg" width="300">
  <!-- ![](voronoi.svg){width=200px} -->
</div>

**Voronoi, Georgy** (1908). *Nouvelles applications des paramètres continus à la théorie des formes quadratiques*. Journal für die Reine und Angewandte Mathematik. 133 (133): 97–178. doi:10.1515/crll.1908.133.97.


## Диаграмма Вороного

Диаграмма Вороного представляет из себя способ моделирования конкурентных зон

<img src="voronoi.gif" width="400">
<!-- ![https://en.wikipedia.org/wiki/Voronoi_diagram](voronoi.gif){width=450px} -->


## Диаграмма Вороного

Для вычисления диаграммы могут быть использованы различные метрики

<div style="display: inline-block; width: 45%; vertical-align: top;">
  **Евклидово расстояние**

  $d_{12} = \sqrt{(x_1-x_2)^2 + (y_1 - y_2)^2}$
  
  <img src="voronoi_std.svg" width="300">
  
  <!-- ![](voronoi_std.svg) -->
</div>

<div style="display: inline-block; width: 45%; vertical-align: top; margin-left: 2%">
  **Манхэттенское расстояние**

  $d_{12} = |x_1-x_2| + |y_1 - y_2|$
  
  <img src="voronoi_mnh.svg" width="300">
  <!-- ![](voronoi_mnh.svg) -->
</div>



## Регионизация точек

**Методы регионизации:**

1. Ограничивающие прямоугольники
2. Выпуклая оболочка
3. Невыпуклые оболочки ($\alpha$-shape, $\chi$-shape)



## Ограничивающий прямоугольник (envelope)

<img src="envelope.png" width="800">
<!-- ![](envelope.png){width=800px} -->

- Наиболее простой тип оболочки, который используется в ГИС для описания территориального охвата слоя (*экстент*)

- Для построения в общем случае нужно 4 точки, которые обладают минимальным и максимальным значением координат из всего множества



## Выпуклая оболочка (convex hull)

<img src="chull.png" width="400">
<!-- ![](chull.png){width=400px} -->

- **Выпуклой оболочкой** множества $p$ называется
наименьшее выпуклое множество, содержащее $p$

- Выпуклая оболочка обозначается как $Conv(p)$

- Выпуклая оболочка на плоскости является *пересечением всех полуплоскостей, содержащих* $p$

- Существует несколько алгоритмов построения $Conv(p)$



## Выпуклая оболочка
<div style="display: inline-block; width: 45%; vertical-align: top;">
  **Аналогия**

  Представьте себе лассо, которое накидывается на множество гвоздей, битых в доску:
  ![](lasso.png){width=330px}
  
</div>

<div style="display: inline-block; width: 45%; vertical-align: top; margin-left: 2%">
  **Выпуклое и невыпуклое**

  *Выпуклое множество* в аффинном или векторном пространстве — множество, содержащее вместе с любыми двумя точками соединяющий их отрезок:
  
  <img src="convex_concave.png" width="400">
  <!-- ![](convex_concave.png) -->
</div>



## Выпуклая оболочка

**Алгоритм Джарвиса**

<div style="display: inline-block; width: 55%; vertical-align: top;">

  1. Найти точку $p_0$ с наименьшим значением координаты $X$. Добавить в результат.
  2. Найти точку $p_1$, образующую наименьший угол поворота по часовой стрелке относительно направления оси $Y$. Добавить в результат.
  3. Найти все оставшиеся точки выпуклой оболочки $p_i, i = 2..k$, выбирая каждый раз такую точку $p_i$, что угол поворота от $p_{i-2} p_{i-1}$ к $p_{i-2} p_{i-1}$ наименьший. Остановиться, когда $p_i = p_0$

</div>

<div style="display: inline-block; width: 40%; vertical-align: top; margin-left: 2%">
  ![](jarvis.png)
</div>

**Jarvis, R. A.** (1973). *On the identification of the convex hull of a finite set of points in the plane*. Information Processing Letters 2: 18–21. doi:10.1016/0020-0190(73)90020-3.

## Выпуклая оболочка

**Алгоритм Джарвиса**

![](jarvis.gif)

**Jarvis, R. A.** (1973). *On the identification of the convex hull of a finite set of points in the plane*. Information Processing Letters 2: 18–21. doi:10.1016/0020-0190(73)90020-3.


## Минимальный по площади ограничивающий прямоугольник

**Минимальный по площади ограничивающий прямоугольник** (*minimum bounding rectangle  MBR*) является наименьшим по площади среди всех прямоугольников, охватывающих данное множество точек

<div style="display: inline-block; width: 45%; vertical-align: top;">
  ![](mbr.png)
</div>

<div style="display: inline-block; width: 45%; vertical-align: top; margin-left: 2%">
  Согласно теореме Фримана-Шапиро *одна из сторон MBR должна касаться выпуклой оболочки*.

  **Freeman, H.; Shapira, R.** (1975), *Determining the minimum-area encasing rectangle for an arbitrary closed curve*. Communications of the ACM, 18: 409–413, MR 0375828, doi:10.1145/360881.360919.
</div>




## Алгоритм Rotating Calipers

Поворачиваем ограничивающий прямоугольник, совмещая его с одной из сторон выпуклой оболочки. Из них выбираем минимальный по площади.

![](calipers.png){width=700px}

**G.T.Toussaint** (1983). *Solving geometric problems with the rotating calipers*. Proceedings of IEEE MELECON'83, Athens, Greece, May 1983, pp. A10. 02/1-4.



## Альфа-оболочка

**Альфа-оболочка ($\alpha$-shape)**  обобщение понятия выпуклой оболочки, позволяющее строить оболочки, более точно описывающие форму множества, в том числе и вогнутые оболочки. Альфа-оболочка является площадной компонентой *альфа-комплекса ($\alpha$-complex)*, который строится на основе триангуляции Делоне множества точек.

![](ashape.png){width=600px}

**Edelsbrunner H, Kirkpatrick D, Seidel R **(1983) *On the shape of a set of points in the plane*. IEEE Transactions on Information Theory, 29:551–559. doi: 10.1109/TIT.1983.1056714



## Альфа-комплекс

**Альфа-комплекс ($\alpha$-complex)**  подмножество триангуляции Делоне, включающее узлы, а также ребра и треугольники, существующие при заданном радиусе диска $r= 1/\alpha$ (при $\alpha > 0$).

![](acomplex.png){width=900px}

- При увеличении радиуса диска происходит образование и исчезновение циклов.

- При $\alpha = 0$ объединение треугольников альфа-комплекса совпадает с *выпуклой оболочкой* множества точек.



## Типы альфа-комплексов
<div style="display: inline-block; width: 45%; vertical-align: top;">
  **Стандартный**

  $\alpha = const$

  ![](acomplex_std.png)
</div>

<div style="display: inline-block; width: 45%; vertical-align: top; margin-left: 2%">
  **Взвешенный**

  $\alpha = f(p)$

  ![](acomplex_wgt.png)
</div>



## Отбор точек

**Алгоритмы отбора:**

1. Разделения населенных пунктов (*settlement-spacing*)

1. Растущей окружности (*circle-growth*)

1. Взвешенной эффективной площади (*effective area*)

**Все алгоритмы** используют весовые коэффициенты для оценки важности точке. В качестве аргумента весовой функции могут быть использованы:

- значение показателя в точке
- статус (ранг) точки
- расстояние до ближайшей точки
- эффективная площадь точки (ячейка Вороного)



## Алгоритм Settlement-spacing

Вокруг каждой точки строится окружность радиуса $R_i = C/W_i$, где $W_i$ — вес точки, а $С$ — константа. Точки сортируются в порядке уменьшения $W_i$.

1. Выбирается первая точка. Добавляется в результат.

1. Выбирается следующая точка. Если она содержит в окружности ранее добавленную точку, она исключается. Если нет, то добавляется в результат.

2. Шаг 2 повторяется, пока не будет достигнут требуемый процент отбора точек, либо не исчерпается множество точек.

![](stl-spacing.png)

**Langran C. E. and Poiker T. K.** *Integration of name selection and name placement* // Proceedings of II International Symposium on Spatial Data Handling, 1986, pp. 50–64.



## Алгоритм Circle-growth

Радиус окружности $R = C \times W_i$ прямо пропорционален весу точки $W_i$.

1. Начальное значение $С$ выбирается таким образом, чтобы окружность наиболее важной точки не накрывала ни одну соседнюю точку.

1. Значение $С$ увеличивается, при этом удаляются те точки, окружности которых оказались целиком внутри окружности точки более высокого ранга.

1. Процедура продолжается до тех пор пока, не будет достигнут требуемый процент удаляемых точек.

![](circ-growth.png)

**van Kreveld, M., van Oosterom, R., and Snoeyink, J.** *Efficient settlement selection for interactive display*, in Proceedings of AutoCarto 12, Bethesda, MD, 1995, pp. 287–296.



## Алгоритм эффективной площади

1. Построить оболочку точек (convex hull, $\alpha$-shape)

2. Построить диаграмму Вороного точек в пределах оболочки.

3. Вычислить веса каждой точки обратно пропорционально площади ее ячейки Вороного $W_i = A_i^{-1}$. Пометить все точки как активные.

4. Удалить активную точку с наименьшим весом.

5. Перестроить локально диаграмму Вороного для соседей точки первого порядка. Деактивировать соседей (запретить их удаление).

6. Повторять шаги 4-5 для оставшихся точек, пока не будут деактивированы все точки или пока не будет достигнут требуемый процент отбора.

7. Если не достигнут требуемый процент отбора точек, активировать все точки и перейти к шагу 4. В противном случае завершить обработку

**Ai T., Liu Y.**  *A method of point cluster simplification with spatial distribution properties preserved*, Acta Geodaetica et Cartographica Sinica, 25(1), 35–41, 2002.



## Алгоритм эффективной площади

<div style="display: inline-block; width: 45%; vertical-align: top;">
  **До:**

  ![](effa_source.png)
</div>

<div style="display: inline-block; width: 45%; vertical-align: top; margin-left: 2%">
  **После:**

  ![](effa_result.png)
</div>

**Ai T., Liu Y.**  *A method of point cluster simplification with spatial distribution properties preserved*, Acta Geodaetica et Cartographica Sinica, 25(1), 35–41, 2002.



## Алгоритм эффективной площади

**Локальное перестроение диаграммы Вороного:**

![](effa_recalc.png)

- выбрать соседей первого и второго порядка, построить для них диаграмму Вороного

- выбрать полигоны Вороного соседей первого порядка и заменить ими полигоны Вороного в исходной диаграмме

**Деактивация** соседей первого порядка позволяет избежать прореживания множества точек в местах их значительного скопления



## Алгоритм взвешенной эффективной площади

Вес точки масштабируется пропорционально ее значимости, а не только эффективной площади: $W_i = С_i \times A_i^{-1}$, где параметр $С_i$ можно представить как средневзвешенную сумму баллов за факторы:

$$
С_i = \frac{\sum w_j f_{ij}}{\sum w_j}
$$

где $w_j$ – вес $j$-го фактора, $f_{ij}$ — значение $j$-го фактора в $i$-й точке.

**Yan, H. W and Li, Z. L.**, *A Voronoi-based algorithm for point cluster generalization* // Proceedings of 11th International Conference on Geometry and Graphics, August 2004, Guangzhou, 2004.

**Samsonov T., Krivosheina A.**  *Joint generalization of city points and road network for small-scale mapping* // Proceedings of Seventh International Conference on Geographic Information Science GIScience, September 18-21, 2012. — Columbus, Ohio, 2012. — P. 1–7.



## Районирование

Можно выполнить районирование территории по густоте размещения и для каждого района устанавливать свои допуски и критерии генерализации

![](sel_regions.png){width=700px}

**Самсонов Т. Е., Кривошеина А. М.** *Автоматизация отбора населенных пунктов с учетом пространственной неравномерности их распределения для целей мелкомасштабного картографирования* // Известия высших учебных заведений. Геодезия и аэрофотосъемка. — 2015. — № 1. — С. 74–82.



## Районирование

Можно выполнить районирование территории по густоте размещения и для каждого района устанавливать свои допуски и критерии генерализации

![](sel_regions2.png){width=700px}

**Самсонов Т. Е., Кривошеина А. М.** *Автоматизация отбора населенных пунктов с учетом пространственной неравномерности их распределения для целей мелкомасштабного картографирования* // Известия высших учебных заведений. Геодезия и аэрофотосъемка. — 2015. — № 1. — С. 74–82.



## Графическая оценка результатов

**До генерализации:**

![](graph_est_src.png)

1 у.е. — пунсон населенного пункта наименьшего класса



## Графическая оценка результатов

**После генерализации:**

![](graph_est_dest.png)

1 у.е. — пунсон населенного пункта наименьшего класса



## Численная оценка результатов

**Закон квадратного корня:**  *количество объектов уменьшается пропорционально квадратному корню отношения исходного и результирующего масштабов* (Topfer, Pillewizer, 1966). В более общем виде закон можно сформулировать следующим образом:

$$
N_T = N_S \sqrt {\left(\frac{S_S}{S_T}\right)^x}
$$

где $N_T$  количество объектов в целевом масштабе, $N_S$  количество объектов в исходном масштабе, $S_T$  целевой масштаб, $S_S$  исходный масштаб. Параметр $x$ определяет степень отбора при генерализации и принимает следующие характерные значения:

- 0 — нет отбора
- (0, 4) — *увеличение* густоты
- 4 — *сохранение* густоты
- \> 4 — *уменьшение* густоты

**Topfer, F. and Pillewizer, W.** (1966) *The Principles of Selection*. The Cartographic Journal, 3, 10-16. http://dx.doi.org/10.1179/caj.1966.3.1.10



## Численная оценка результатов

Оценка по закону Топфера показывает, что, как правило, при уменьшении масштаба наблюдается выравнивание плотности объектов по различным районам, а также общее уплотнение объектов:

<div style="display: inline-block; width: 45%; vertical-align: top;">

Класс | Значение параметра $x$
|--
1  | 4,2
2  | 3,0
3  | 2,0
4  | 1,2
Всего  | 3,8

</div>

<div style="display: inline-block; width: 50%; vertical-align: top; margin-left: 2%">

![](sel_regions2.png){width=500px}

</div>



## Кластеризация


## Постановка задачи кластеризации

**Дано**:

- $X$  пространство объектов;
- $X^l$ = $\{x_1, ..., x_l\}$  обучающая выборка;
- $\rho: X \times X \rightarrow [0, \infty)$  функция расстояния между объектами.

**Найти:**

- $Y$  множество кластеров;
- $a: X \rightarrow Y$  алгоритм кластеризации,

*Такие что*:

  - каждый кластер состоит из близких объектов
  - объекты разных кластеров существенно различны

Кластеризация относится к методам классификации (обучения) *без учителя*

**К.В.Воронцов** Машинное обучение (курс лекций). [http://www.machinelearning.ru](http://www.machinelearning.ru)


## Кластеризация

**Цели кластеризации:**

1. Упрощение обработки данных
1. Сжатие данных
1. Выделение аномалий (нетипичных объектов)
1. Построение иерархии объектов

**Проблемы кластеризации:**

1. Отсутствие точной постановки задачи
1. Разнообразие критериев качества кластеризации
2. Распространенность эвристических подходов
3. Неизвестное количество кластеров
4. Зависимость результата от выбранной метрики


## Алгоритмы кластеризации

1. Статистическая кластеризация

    - К средних
    - ISODATA
    - ФОРЭЛ (формальные элементы)

1. Иерархическая/графовая кластеризация

1. Плотностная кластеризация (DBSCAN/OPTICS)


## Метод К средних

1. Установить количество кластеров $K$
2. Выбрать случайным образом $K$ точек в качестве центров кластеров
3. Определить для каждой точки ближайший центр кластера
4. Рассчитать новый центр кластера на основе координат его точек
5. Повторять шаги 3-4, до тех пор пока центры кластеров не перестанут менять свое местоположение.

**Steinhaus H.** (1956). *Sur la division des corps materiels en parties.* Bull. Acad. Polon. Sci., C1. III vol IV: 801—804.

**Lloyd S.** (1957). *Least square quantization in PCM’s.* Bell Telephone Laboratories Paper.

**MacQueen J.** (1967). *Some methods for classification and analysis of multivariate observations.* In Proc. 5th Berkeley Symp. on Math. Statistics and Probability, pages 281—297.


## Метод К средних
Пример с четырьмя кластерами:

<img src="kmeans.gif" width="600">
<!-- ![](kmeans.gif){width=600px} -->

[http://shabal.in/visuals/kmeans/](http://shabal.in/visuals/kmeans/)


## Метод К средних

**Свойства метода**

Метод К средних стремится минимизировать суммарное квадратичное отклонение точек кластеров от центров этих кластеров:
  $$
  V = \sum_{i=1}^{k} \sum_{x_j \in S_I} (x_j - \mu_i)^2
  $$
где $k$  число кластеров, $S_i$  полученные кластеры, $\mu_i$  центры кластеров (центры масс векторов этих кластеров)

**Однако**: не гарантируется достижение глобального минимума суммарного квадратичного отклонения $V$, а только одного из локальных минимумов.


## Метод К средних

**Свойства метода**

Все точки результирующих кластров лежат в пределах ячеек диаграммы Вороного для центров этих кластеров:

<img src="kmeans_vor.png" width="400">
<!-- ![](kmeans_vor.png){width=400px} -->

[https://moderndata.plot.ly/voronoi-diagrams-in-plotly-and-r/](https://moderndata.plot.ly/voronoi-diagrams-in-plotly-and-r/)


## Метод К средних

**Свойства метода**

Результат зависит от выбора исходных центров кластеров, их оптимальный выбор неизвестен:

<img src="kmeans-1.png" width="700">
<img src="kmeans-2.png" width="700">

<!-- ![](kmeans-1.png){width=700px} -->
<!-- ![](kmeans-2.png){width=700px} -->

[E.M. Mirkes, K-means and K-medoids applet. University of Leicester, 2011.](http://www.math.le.ac.uk/people/ag153/homepage/KmeansKmedoids/Kmeans_Kmedoids.html)


## Метод К средних

**Свойства метода**

Алгоритм хорошо выделяет только разнесенные в пространстве кластеры выпуклой формы. Пример неудачной кластеризации:

![](kmeans-irr.png){width=500px}


## Метод К средних

**Свойства метода:**

1. Не гарантируется достижение глобального минимума суммарного квадратичного отклонения $V$, а только одного из локальных минимумов.

2. Результат зависит от выбора исходных центров кластеров, их оптимальный выбор неизвестен.

3. Алгоритм хорошо выделяет только кластеры выпуклой формы.

4. Метод может выявлять только заданное количество кластеров, но не их естественное число.


## Метод ISODATA

**ISODATA** означает *Iterative Self-Organizing Data Analysis Technique Algorithm*

Метод начинает работу с одного кластера и выполняет рекурсивное разделение множества вдоль его наиболее протяженной оси до тех пор пока все внутрикластерные расстояния не будут в пределах заданного допуска.

**Ball, Geoffrey H., Hall, David J.** (1965) *Isodata: a method of data analysis and pattern classification* Stanford Research Institute, Menlo Park,United States. Office of Naval Research. Information Sciences Branch


## Метод ISODATA

(1). Установить допустимые значения стандартных отклонений $\sigma_x^{max}$, $\sigma_y^{max}$, минимальное расстояние между кластерами $d_max$ (опционально) и требуемое количество кластеров $K$ (опционально).

(2). Распределить $k$ случайных центров кластеров. Допустимо принять $k=1$, тогда местоположение кластера не имеет значения.

(3). Распределить точки в кластеры по расстоянию до ближайшего центра.

(4). Вычислить расстояния $d$ между центрами кластеров. Если среди них есть такие что $d < d_{max}$, произвести объединение центров, вычислив координаты, взвешенные на количество точек, содержащихся в кластере. Заново перераспределить между ними точки.

(5). Для каждого кластера вычислить значения выборочного среднего $\mu_x, \mu_y$ и стандартного отклонения $\sigma_x$ и $\sigma_y$ координат по осям $X$ и $Y$.

## Метод ISODATA

(6). Разбить пополам значением $\mu_x$ или $\mu_y$ все кластеры, в которых $\sigma_x > \sigma_x^{max}$ или $\sigma_y > \sigma_y^{max}$. Если в кластере $\sigma$ превышает допуск по обоим направлениям, он разбивается по направлению, в котором $\sigma$ больше.

(7). Вычислить центры разбитых кластеров, включить их в общее множество центров.

(8). Повторять шаги 3-5, пока во всех кластерах значения $\sigma_x$ и $\sigma_y$ на станут меньше соответствующих значений $\sigma_x^{max}$ и $\sigma_y^{max}$ или когда не будет достигнуто требуемое количество кластеров $K$.

## Метод ISODATA

![**Исходный набор данных** (Ball, Hall, 1965)](isodata-0.png){width=450px}

Вес и рост спортсменов из разных видов спорта


## Метод ISODATA

<!-- ![**Размещение исходных центров** (Ball, Hall, 1965)](isodata-1.png){width=500px} -->
<img src="isodata-1.png" width="450">

Даже если центры выбраны неудачно, в результате они разместятся в подходящих местах.


## Метод ISODATA

<!-- ![**Разбиение диаграммой Вороного** (Ball, Hall, 1965)](isodata-2.png){width=500px} -->
<img src="isodata-2.png" width="450">

**Разбиение диаграммой Вороного** 

## Метод ISODATA

<!-- ![**Распределение точек по кластерам** (Ball, Hall, 1965)](isodata-3.png){width=500px} -->
<img src="isodata-3.png" width="450">

**Распределение точек по кластерам**

## Метод ISODATA

<!-- ![**Вычисление средней точки** (Ball, Hall, 1965)](isodata-4.png){width=500px} -->
<img src="isodata-4.png" width="450">

**Вычисление средней точки**

## Метод ISODATA

<!-- ![**Разделение центров** (Ball, Hall, 1965)](isodata-5.png){width=500px} -->
<img src="isodata-5.png" width="450">

**Разделение центров**

## Метод ISODATA

<!-- ![**Разбиение диаграммой Вороного** (Ball, Hall, 1965)](isodata-6.png){width=500px} -->
<img src="isodata-6.png" width="450">

**Разбиение диаграммой Вороного**

## Метод ISODATA

<!-- ![**Распределение точек по кластерам** (Ball, Hall, 1965)](isodata-7.png){width=500px} -->
<img src="isodata-7.png" width="450">

**Распределение точек по кластерам**

## Метод ISODATA

<!-- ![**Центры кластеров** после итерации 2 (Ball, Hall, 1965)](isodata-8.png){width=500px} -->
<img src="isodata-8.png" width="450">

**Центры кластеров** после итерации 2. Точка-выброс помечена стрелочкой


## Метод ISODATA

<!-- ![**Центры кластеров** после итерации 3 (Ball, Hall, 1965)](isodata-9.png){width=500px} -->
<img src="isodata-9.png" width="450">

**Центры кластеров** после итерации 3. Точка-выброс образовала самостоятельный кластер


## Метод ISODATA

<!-- ![**Разбиение кластеров** (Ball, Hall, 1965)](isodata-10.png){width=500px} -->
<img src="isodata-10.png" width="450">

**Разбиение кластеров**

## Метод ISODATA

<!-- ![**Распределение точек по кластерам** (Ball, Hall, 1965)](isodata-11.png){width=500px} -->
<img src="isodata-11.png" width="450">

**Распределение точек по кластерам**

## Метод ISODATA

<!-- ![**Вычисление новых центров кластеров** (Ball, Hall, 1965)](isodata-12.png){width=500px} -->
<img src="isodata-12.png" width="450">

**Вычисление новых центров кластеров**

## Метод ISODATA

<!-- ![**Слияние близких центров** (Ball, Hall, 1965)](isodata-13.png){width=500px} -->
<img src="isodata-13.png" width="450">

**Слияние близких центров**

## Метод ISODATA

<!-- ![**Разбиение на кластеры** (Ball, Hall, 1965)](isodata-14.png){width=500px} -->
<img src="isodata-14.png" width="450">

**Разбиение на кластеры**

## Метод ISODATA

<!-- ![**Центры кластеров** (Ball, Hall, 1965)](isodata-15.png){width=500px} -->
<img src="isodata-15.png" width="450">

**Центры кластеров**

## Метод ISODATA

<!-- ![**Центры кластеров и их слияние** (Ball, Hall, 1965)](isodata-16.png){width=500px} -->
<img src="isodata-16.png" width="450">

**Центры кластеров и их слияние**

## Метод ISODATA

<!-- ![**Итоговые центры** (Ball, Hall, 1965)](isodata-17.png){width=500px} -->
<img src="isodata-17.png" width="450">

**Итоговые центры**

## Метод ISODATA

**По сравнению с К средних:**

1. Не обязательно задавать количество кластеров.

2. Более робастный метод вычисления итоговых кластеров.

3. Точно так же хорошо справляется только с изометричными кластерами, однако по прежнему не эффективен при выделении кластеров неправильной формы


## FOREL (ФОРмальные ЭЛементы)

<!-- **Параметры: ** -->

- $U:= X^l$  множество некластеризованных точек
- $K$  количество кластеров
- $R$  радиус поиска.

<!-- **Алгоритм:** -->

1. Выбрать случайную точку $p_0$
2. Образовать кластер с центром в $p_0$ и радиусом $R$
3. Переместить центр $p_0$ в центр масс кластера
4. Повторять шаги 2-3, пока состав кластера $K_0$ не стабилизируется
5. Исключить кластеризованные точки из множества $U := K \setminus K_0$
6. Повторять шаги 2-5, пока в выборке есть некластеризованные точки

**Ёлкина В.Н., Ёлкин Е.А., Загоруйко Н.Г.** *О применении методики распознавания образов к решению задач палеонтологии*, 1967


## FOREL (ФОРмальные ЭЛементы)

**Преимущества: **

- Точность минимизации функционала качества (при удачном подборе параметра R)
- Наглядность визуализации кластеризации
- Сходимость алгоритма
- Возможность операций над центрами кластеров — они известны в процессе работы алгоритма
- Возможность подсчета промежуточных функционалов качества, например, длины цепочки локальных сгущений
- Возможность проверки гипотез схожести и компактности в процессе работы алгоритма

## FOREL (ФОРмальные ЭЛементы)

**Недостатки: **

- Относительно низкая производительность (решается введением функции пересчета поиска центра при добавлении 1 объекта внутрь сферы)
- Плохая применимость алгоритма при плохой разделимости выборки на кластеры
- Неустойчивость алгоритма (зависимость от выбора начального объекта)
- Произвольное по количеству разбиение на кластеры
- Необходимость априорных знаний о ширине (диаметре) кластеров


## Иерархическая кластеризация

**Алгоритм** (Lance, Williams, 1967) основан на пересчете расстояний $R_{UV}$ между кластерами $U$ и $V$:

(1). Представить все кластеры как одноэлементные: $C_1 := \Bigl\{ \{x_1\}, ..., \{x_l\} \Bigr\}$.

(2). Рассчитать расстояния между ними $R_{\{x_i\}\{x_j\}} = \rho_{x_i, x_j}$.

(3). Установить переменную цикла $t = 2$.

(4). Найти пару кластеров с минимальным расстоянием $\rho_{ij}$.

(5). Объединить их в один кластер: $W := U \cup V$; $C_t := C_{t-1} \{W\} \setminus \{U, V\}$.

## Иерархическая кластеризация

(6). Пересчитать расстояния $R_{WS}$ от нового кластера $W$ до всех кластеров $S \in С_t$ по формуле Ланса-Уильямса: $R_{WS} := \alpha_{U}R_{US} + \alpha_V R_{VS} + \beta R_{UV} + \gamma |R_{US} - R_{VS}|$.

(7). Установить $t = t + 1$.

(8). Повторять шаги 4-7, пока $t \leq l$.

**Lance G. N., Willams W. T.** *A general theory of classification sorting strategies. 1. hierarchical systems* // Comp. J. — 1967. — no. 9. — Pp. 373–380

## Варианты расстояний
<!-- ![](hierch-dist1.png){width=900px} -->
<img src="hierch-dist1.png" width="700">

**К.В.Воронцов** Машинное обучение (курс лекций). [http://www.machinelearning.ru](http://www.machinelearning.ru)


## Варианты расстояний
<!-- ![](hierch-dist2.png){width=900px} -->
<img src="hierch-dist2.png" width="700">

**К.В.Воронцов** Машинное обучение (курс лекций). [http://www.machinelearning.ru](http://www.machinelearning.ru)


## Дендрограммы

**Расстояние ближнего соседа**

<!-- ![](hierch-dend1.png){width=900px} -->
<img src="hierch-dend1.png" width="700">

**К.В.Воронцов** Машинное обучение (курс лекций). [http://www.machinelearning.ru](http://www.machinelearning.ru)


## Дендрограммы

**Расстояние дальнего соседа**

<!-- ![](hierch-dend2.png){width=900px} -->
<img src="hierch-dend2.png" width="700">

**К.В.Воронцов** Машинное обучение (курс лекций). [http://www.machinelearning.ru](http://www.machinelearning.ru)


## Дендрограммы

**Групповое среднее**

<!-- ![](hierch-dend3.png){width=900px}-->
<img src="hierch-dend3.png" width="700">

**К.В.Воронцов** Машинное обучение (курс лекций). [http://www.machinelearning.ru](http://www.machinelearning.ru)


## Дендрограммы

**Расстояние Уорда**

<!-- ![](hierch-dend4.png){width=900px} -->
<img src="hierch-dend4.png" width="700">

**К.В.Воронцов** Машинное обучение (курс лекций). [http://www.machinelearning.ru](http://www.machinelearning.ru)


## Иерархическая кластеризация

1. Рекомендуют пользоваться расстоянием Уорда

1. Имеет смысл построить несколько вариантов и выбрать лучший

1. Уровень кластеризации получается путем отсечения дерева по заданному расстоянию.

<!-- ![](hierch-res.png){width=800px} -->
<img src="hierch-res.png" width="500">

**К.В.Воронцов** Машинное обучение (курс лекций). [http://www.machinelearning.ru](http://www.machinelearning.ru)


## Кратчайший незамкнутый путь

**Алгоритм:**

1. Пометить все точки как изолированные
1. Найти пару вершин с наименьшим расстоянием и соединить их ребром. Пометить вершины как неизолированные
2. Найти изолированную точку, ближайшую к некоторой неизолированной
3. Соединить эти точки ребром
4. Повторять шаги 2-3, пока остаются изолированные точки
5. Удалить K-1 самых длинных рёбер.

**Недостатки**:

- необходимость задавать число кластеров
- высокая чувствительность к шуму.


## DBSCAN

**DBSCAN** *(Density-based spatial clustering of applications with noise)*  алгоритм плотностной кластеризации, который группирует плотно упакованные точки.

<!-- <div style="display: inline-block; width: 55%; vertical-align: top;"> -->

  1. Точка $p$ является *ядерной (core)*, если ее $\epsilon$-окрестность содержит не менее $minPts$ точек. Эти точки именуются *прямо достижимыми* от $p$
  2. Точка $q$ является *достижимой (reachable)* от точки $p$, если существует такая последовательность точек $p_1, ..., p_n$, $p_1 = p$, $p_n = q$ в которой каждая точка $p_{i+1}$ прямо достижима от $p_i$. Все точки, кроме $q$ должн быть ядерными
  3. Точка $r$ является *выброшенной (outlier)*, если оне не достижима ни от одной другой точки

<!-- </div> -->

<!-- <div style="display: inline-block; width: 45%; vertical-align: top; margin-left: 2%"> -->
## DBSCAN

  Если $A$  ядерная точка, то она формирует кластер со всеми точками, которые достижимы от нее.  Точки $B$ и $С$ являются граничными (edge), поскольку входят в кластер, но при этом не являются ядерными. Точка $N$ выброшена:
<img src="dbscan.svg" width="300">
  <!-- ![](dbscan.svg){width=300px} -->
  [https://en.wikipedia.org/wiki/DBSCAN](https://en.wikipedia.org/wiki/DBSCAN)
<!-- </div> -->

**Ester, Martin, Hans P Kriegel, Jorg Sander, and Xiaowei Xu**. 1996. *A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise.* Proceedings of the 2nd International Conference on Knowledge Discovery and Data Mining, 226–31. doi:10.1.1.71.1980.

---
<!-- ## DBSCAN -->

<!-- **Алгоритм:** -->

<!-- 1. Задать С = 0 -->
<!-- 1. Для каждой точки $p$ из множества $P$ -->
i. Найти множество точек $N$, входящих в $\epsilon$-окрестность точки $p$
i. Если $|N| < minPts$, то пометить точку $p$ как выброшенную и перейти на новую итерацию.
i. Если $|N| \geq minPts$, то создать новый номер кластера $C = C+1$ (изначально C = 0) и пометить им точку $p$
i. Создать множество точек $Q = N \setminus \{p\}$
i. Для каждой точки $q$ из множества $Q$:
    1. Если $q$ помечена как выброшенная, пометить $q$ номером кластера $C$
    1. Если $q$ имеет метку, перейти на новую итерацию.
    1. Если $q$ не имеет метки, то:
        i. пометить $q$  номером кластера $C$
        ii. найти множество точек $K$, входящих в $\epsilon$-окрестность $q$
        iii. если $|K| \geq minPts$, то $Q = Q \cup K$ (добавить $K$ к $Q$)

**Ester, Martin, Hans P Kriegel, Jorg Sander, and Xiaowei Xu**. 1996. *A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise.* Proceedings of the 2nd International Conference on Knowledge Discovery and Data Mining, 226–31. doi:10.1.1.71.1980.


## DBSCAN

**Пуассоновский (случайный) точечный процесс:**

<img src="dbscan_uniform.gif" width="500">

<!-- ![](dbscan_uniform.gif) -->

*Visualizing DBSCAN Clustering:*

[https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/](https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/)


## DBSCAN

**Кластерный процесс Томаса (смесь нормальных распределений):**

<img src="dbscan_gaussian.gif" width="500">
<!-- ![](dbscan_gaussian.gif) -->

*Visualizing DBSCAN Clustering:*

[https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/](https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/)


## DBSCAN

**Смайлик:**

<img src="dbscan_face.gif" width="500">
<!-- ![](dbscan_face.gif) -->

*Visualizing DBSCAN Clustering:*

[https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/](https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/)


## DBSCAN

<!-- <div style="display: inline-block; width: 45%; vertical-align: top;"> -->

**Достоинства:**

1. *DBSCAN* не требует указания количества кластеров.

1. *DBSCAN* может найти кластеры произвольной формы. Он может даже найти кластер, полностью окруженный другим кластером, но не связанный с ним.

1. *DBSCAN* имеет представление о шуме и устойчив к выбросам.

1. *DBSCAN* требует всего два параметра и в основном нечувствителен к упорядочению точек в исходном множестве. Тем не менее, точки, расположенные на краю двух разных кластеров, могут менять кластерное членство.

1. *DBSCAN* способен использовать пространственные индексы для эффективного поиска точек в окрестности.

<!-- </div> -->

<!-- <div style="display: inline-block; width: 45%; vertical-align: top; margin-left: 2%"> -->

## DBSCAN

**Недостатки:**

1. *DBSCAN* не является полностью детерминированным: граничные точки, доступные из более чем одного кластера, могут быть частью любого кластера, в зависимости от порядка обработки данных.

1. Качество *DBSCAN* зависит от метрики расстояния, используемой в функции запроса диапазона (*region query*). Наиболее распространенной метрикой расстояния является евклидово расстояние, однако в пространствах высокой размерности подбор подходящего значения $\epsilon$ вызывает большие трудности.

1. *DBSCAN* не может хорошо сгруппировать наборы данных в которых кластеры имеют разную плотность. Комбинация $minPts$ и $\epsilon$ характеризует только определенный масштаб кластеризации.

<!-- </div> -->


## DBSCAN

**Выбор параметров**

(1). Для определения оптимальной величины $\epsilon$ рекомендуется построить функцию среднего расстояния до $minPts-1$ ближайших соседей в зависимости от $\epsilon$. Оптимальными считаются значения $\epsilon$, при которых наблюдается наиболее интенсивное изменение роста функции (перегиб):

<img src="dbscan_eselect.png" width="500">
<!-- ![](dbscan_eselect.png){width=600px} -->

**Sander, Jörg; Ester, Martin; Kriegel, Hans-Peter; Xu, Xiaowei** 1998. "Density-Based Clustering in Spatial Databases: The Algorithm GDBSCAN and Its Applications". Data Mining and Knowledge Discovery. Berlin: Springer-Verlag. 2 (2): 169–194. doi:10.1023/A:1009745219419


## DBSCAN

**Выбор параметров**

(2). Количество точек в кластере должно быть больше размерности пространства: $minPts \geq D +1$. В качестве отправной точки рекомендуется взять значение $minPts = 2D$

(3). Функция вычисления расстояния должна выбираться в соответствии с сущностью точек. Например, если координаты точек заданы широтой и долготой, для вычисления расстояний следует использовать *обратную геодезическую задачу*.

**Sander, Jörg; Ester, Martin; Kriegel, Hans-Peter; Xu, Xiaowei** 1998. "Density-Based Clustering in Spatial Databases: The Algorithm GDBSCAN and Its Applications". Data Mining and Knowledge Discovery. Berlin: Springer-Verlag. 2 (2): 169–194. doi:10.1023/A:1009745219419


<!-- ## OPTICS -->

<!-- OPTICS является модификацией алгоритма DBSCAN, который решает одну из его основных проблем  невозможность выделять кластеры различной плотности. Точки линейно упорядочиваются таким образом, что близкие друг другу точки становятся соседями в последовательности: -->

<!-- <img src="OPTICS.svg" width="700"> -->
<!-- <!-- ![](OPTICS.svg){width=800px} --> -->


## Вычисление центров кластеров

**Возможны различные варианты:**

<img src="cluster_centers.png" width="500">

<!-- ![](cluster_centers.png){width=500px} -->


## Критерии качества кластеризации:

**Среднее внутрикластерное расстояние**:

$$
F_0 = \frac{\sum_{i < j} [a_i = a_j] \rho(x_i, x_j)}{\sum_{i < j} [a_i = a_j]} \rightarrow min
$$

**Среднее межкластерное расстояние**:

$$
F_1 = \frac{\sum_{i < j} [a_i \neq a_j] \rho(x_i, x_j)}{\sum_{i < j} [a_i \neq a_j]} \rightarrow max
$$

<!-- где $[\cdot]$  индикаторная функция в нотации Айверсона: -->

<!-- $$ -->
<!-- [P] = \begin{cases} -->
<!--   1, \text{if } P \text{ is TRUE};\\ -->
<!--   0, \text{if } P \text{ is FALSE}. -->
<!-- \end{cases} -->
<!-- $$ -->

**Отношение пары функционалов**:

$$
F_0/F_1 \rightarrow min
$$
