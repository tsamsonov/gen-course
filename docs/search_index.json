[["index.html", "Картографические базы данных Генерализация пространственных данных Введение", " Картографические базы данных Генерализация пространственных данных Тимофей Самсонов 2021-12-10 Введение Картографические базы данных "],["points-sel-work.html", "A Задание №1. Отбор точечных объектов Реализация алгоритма Settlement Spacing Реализация модели оценки условной графической нагрузки Отбор населенных пунктов для карты масштаба 1:4 000 000 Реализация алгоритма взвешенной эффективной площади Применение алгоритма взвешенной эффективной площади Оценка полученных результатов Отчет", " A Задание №1. Отбор точечных объектов Цель задания — освоение методики автоматизированного отбора точечных объектов на примере населенных пунктов. Задачи: Изучить принципы, заложенные в методы отбора (исключения) точек Settlement Spacing (прореживание населенных пунктов) и Voronoy-based (взвешенной эффективной площади). Реализовать метод Settlement Spacing в виде инструмента геообработки Python Toolbox. Подготовить слой населенных пунктов субъекта РФ на основе данных OpenStreetMap. Реализовать оценку графической нагрузки в виде инструмента геообработки Python Toolbox. Выполнить параметризацию коэффициента масштабирования для метода Settlement Spacing при графической нагрузке \\(2\\), \\(4\\) и \\(6\\) \\(см^{-2}\\) Осуществить автоматизированный отбор населенных пунктов для масштаба \\(1:4~000~000\\). Реализовать метод взвешенной эффективной площади в виде инструмента геообработки Python Toolbox Осуществить автоматизированный отбор населенных пунктов для масштаба \\(1:4~000~000\\), оставив такое же количество населенных пунктов, что и в методе Settlement Spacing. Выполнить численную, графическую и географическую оценку результатов генерализации обоими методами. Сравнить результаты между собой. При выполнении задания в качестве справочника используется официальное руководство по созданию инструментов Python Toolbox. Реализация алгоритма Settlement Spacing Входные параметры: Точечный слой (Input Points). Поле важности точки (Importance Field). Поле сохранения точки (Remain Field). Масштабирующий коэффициент (Scale). Входные данные: Тестирование инструмента производится на примере слоя poppnt_ural (можно вырезать из него небольшой фрагмент из нескольких десятков точек. Результат: По результатам выполнения инструмента каждой точке в поле Remain Field должно быть проставлено значение \\(1\\) (оставить) или \\(0\\) (убрать). Алгоритм решения задачи: Отсортировать точки в соответствии со значением поля Importance так чтобы первыми были точки с наибольшим весом (Sort). Добавить в полученный класс пространственных объектов поле Remain Field. Создать слой из него (Make Feature Layer). Создать обновляющий курсор, который будет ходить по всем точкам пространственных объектов (arcpy.da.UpdateCursor) в порядке уменьшения важности точки. Организовать цикл for по всем строками итератора, выполнив следующие действия для текущей точки: 4.2. Извлечь значение поля Importance (Get Field Value) 4.3. Вычислить радиус буферной зоны (Calculate Value) как частное от деления входного параметра Scale и значения поля Importance (чем важнее точка, тем меньше будет радиус зоны). 4.4. Построить буферную зону, используя вычисленное значение 2.3 (Buffer). 4.5. Выбрать в слое (3) уже отобранные точки по значению атрибута (Select Layer by Attributes). 4.6. Довыбрать (SUBSET_SELECTION) буферной зоной (4.4) отобранные точки (4.5) с помощью пространственного запроса (Select Layer by Location). 4.7. Подсчитать количество отобранных точек (Get Count). 4.8. Вычислить флаг отбора для текущей точки (2.1), в зависимости от того, сколько точек выбралось на предыдущем шаге. 4.9. Записат результат в поле сохранения точки через курсор. 4.10. Обновить текущую строку (updateRow) через курсор. Реализация модели оценки условной графической нагрузки Условная графическая нагрузка – средневзвешенное количество точек на единицу площади, где в качестве веса выступает размер точки, используемый при ее отображении на карте Входные параметры: Точечный слой. Поле Size Field, отвечающее за графический вес точки (диаметр значка). Пространственное разрешение сетки (в метрах). Выходной слой сетки. Требования к входным данным: Поле Size Field должно содержать размеры значков, используемых для визуализации точек. Если значения всех размеров равны \\(1\\), вы получите обычную густоту точек на единицу площади. Алгоритм решения задачи: Построить регулярную сетку с заданным разрешением и охватом, покрывающим входной набор точек с небольшим запасом. Подсказка: вам необходимо построить горизонтальный ограничивающий прямоугольник (Minimum Bounding Geometry), буферизовать его на величину разрешения сетки (Buffer) и подать буфер в качестве экстента в инструмент генерации регулярной сетки (Create Fishnet). Подсчитать суммарный графический вес точек в каждой ячейке и записывает результат в новое поле. Подсказка: вам понадобятся инструменты статистики (Tabulate Intersection), и присоединения поля (Join Field). Сохранить полученную сетку в выходной файл. Отбор населенных пунктов для карты масштаба 1:4 000 000 В данной — заключительной — части задания необходимо произвести отбор населенных пунктов, используя собственные скрипты, а также произвести графическую оценку полученных результатов. Алгоритм выполнения задания: Скачать данные OSM на территорию Субъекта Федерации. Не следует для выполнения работы брать субъекты с малым числом населенных пунктов (Мурманская область, Еврейская АО, Республика Калмыкия и т.п.). Внимание: субъекты у всех студентов должны быть разные! Перепроецировать слой settlement-points в наилучшую проекцию для выбранной территории Сформировать поля Importance и Size, используя следующее отображение атрибутов: PLACE Importance Size City 5 5 Town 4 3 Village 3 1 Hamlet 2 1 Locality 1 1 Используя фрагмент данных и значения параметра \\(С\\) (Scale) в диапазоне от \\(1000\\) до \\(10000\\) с шагом \\(1000\\), подобрать регрессионную зависимость вида \\(y = \\alpha x^{-\\beta}\\) между значением параметра масштабирования \\(C\\) (Scale) и средней графической нагрузкой (\\(ед.~на~см^2\\)) в масштабе \\(1:4~000~000\\). Средняя графическая нагрузка оценивается как среднее значение по всем ненулевым ячейкам регулярной сетки. Размер сетки — \\(1~см^2\\) в результирующем масштабе. Найденная зависимость должна иметь примерно следующий вид: Выполнить отбор населенных пунктов с графической нагрузкой \\(2\\), \\(4\\) и \\(6\\) населенных пункта на \\(см^2\\) для масштаба \\(1:4~000~000\\). Соответствующий параметр \\(C\\) (Scale) подберите, используя найденную регрессионную зависимость. Реализация алгоритма взвешенной эффективной площади Входные параметры: Входной точечный слой (Input Points). Поле важности точки (Importance Field). Поле сохранения точки (Remain Field). Процент сохраняемых точек (Selection percentage). Входные данные: Тестирование инструмента производится на примере слоя poppnt_ural (можно вырезать из него небольшой фрагмент из нескольких десятков точек. Результат: По результатам выполнения инструмента каждой точке в поле Remain Field должно быть проставлено значение \\(1\\) (оставить) или \\(0\\) (убрать). Алгоритм решения задачи: Добавить поле сохранение точки (Add Field). Заполнить поле сохранения точки знаечнием \\(1\\) (Calculate Field). По умолчанию все точки сохранены. Создать слой для осуществления выборки точек (Make Feature Layer). Вычислить общее количество точек во входном слое (Get Count). Используя общее число точек и входной процент сохраняемых, вычислить количество точек, которое нужно убрать. Создать счётчик убранных точек и инициировать его значением \\(1\\). Создать цикл while пока счетчик убранных точек меньше значения, вычисленного на шаге (5). Внутри цикла выполнить следующие шаги: 7.1. Выбрать в слое (3) точки, у которых значение поля сохранения равно \\(1\\). 7.2. Построить на их основе в оперативной памяти компьютера (in_memory) диаграмму Вороного (Create Thiessen Polygons) в режиме ALL (сохранить все атрибуты). 7.3. Добавить в нее поле геодезической площади (Add Geometry Attributes в режиме AREA_GEODESIC). 7.4. Добавить в нее поле для веса точки (Add Field). 7.5. Вычислить поле веса как произведение поля важности и геодезической площади AREA_GEO (Calculate Field). Чтобы правильно написать выражение для вычисления, изучите синтаксис вычисления полей в режиме PYTHON_9.3 в справке к инструменту. 7.6. Добавьте поле для замораживания ячеек диаграммы Вороного (Add Field). 7.7. Заполните созданное поле нулями (Calculate Field). По умолчанию все ячейки разморожены. 7.8. Создайте слой для выборки в диаграмме Вороного (7.2) (Make Feature Layer). 7.9. Создайте прогресс-бар типа step (arcpy.SetProgressor) со значениями от \\(0\\) до количества отбираемых точек (5). 7.9. Создайте обновляющий курсор (arcpy.da.UpdateCursor), который будет включать в себя поля сохранения, заморозки и геометрии (всего 3 поля), и ходить по строкам диаграммы Вороного (7.2) в порядке возрастания значений весов (7.4). 7.10. Организуйте цикл for, который для каждой строки курсора будет выполнять следующие действия: Если поле заморозки (7.6) равно \\(1\\), перейти на следующую итерацию цикла. Установить надпись прогресс-бара (arcpy.SetProgressorLabel), которая говорит, что сейчас отбирается i-я точка (6) из общего числа отбираемых (5). Записать в поле отбора значение \\(0\\) через курсор. Обновить текущую строку (updateRow) через курсор. Выбрать в слое диаграммы Вороного (7.8) ячейки, пересекающиеся с геометрией текущей строки (Select Layer by Location). Заполните для выбранных ячеек поле заморозки (7.6) значением \\(1\\) (Calculate Field). Установите значение прогресс-бара (arcpy.SetProgressorPosition) в текущее положение счетчика отбора (6). Увеличите счетчик отбора (6) на единицу. Если счетчик отбора (6) стал больше количества отбираемых точек (5), прервите цикл курсора. 7.11. Выберите в слое диаграммы Вороного (7.8) ячейки, у которых значение флага отбора равно \\(0\\) (Select Layer by Attribute). 7.12. Выберите в слое точек (3) все точки, у которых значение флага отбора равно \\(1\\) (Select Layer by Attribute). 7.13. Довыберите точки, которые пересекаются с выборкой в слое диаграммы Вороного (Select Layer By Location в режиме SUBSET_SELECTION). 7.14. Заполните для выбранных точек поле отбора значением \\(0\\) (Calculate Field). Сбросьте прогресс-бар (arcpy.ResetProgressor). Применение алгоритма взвешенной эффективной площади Используя разработанный инструмент, выполните отбор точек, сохранив процент, аналогичный тому, что был получен в Settlement Spacing при нагрузках \\(2\\), \\(4\\) и \\(6\\). Оценка полученных результатов Выполнить параметризацию параметра \\(x\\) обобщенного закона Топфера для трёх полученных генерализаций по каждому из двух алгоритмов, исходя из предположения, что отношение результирующего и исходного масштаба равно \\(1:40\\). Построить карты графической нагрузки для обоих алгоритмов. Оформить результаты в виде серии карт, отображающей: границу региона множество исходных точек бледно-серым цветом множество отобранных точек черным цветом соответствующего размера подписи основных населенных пунктов картограмму условной графической нагрузки Пример серии карт (вы можете упорядочить изображения другим путем — например, по вертикали): Отчет Работа оформляется в виде письменного отчета, в котором необходимо изложить все этапы исследования: цель и задачи исследования, суть метода отбора точек, суть принципа оценки условной графической нагрузки, суть обобщенного закона Топфера, технология создания инструментов Python Toolbox, определения их параметров и типов параметров описание эксперимента по генерализации, включая: постановку задачи, нахождение регрессионной зависимости, сравнение времени работы модели и скрипта, выполнение отбора, оценку результатов в графическом (карты условной нагрузки) и численном (параметризация обобщенного закона Топфера) виде. "],["points-clust-work.html", "B Задание №2. Кластеризация системы расселения Изучение работы методов кластеризации и регионизации Автоматизация выделения регионов и центроидов кластеров Автоматизация расчета критериев качества кластеризации Кластеризация системы расселения субъекта Отчет", " B Задание №2. Кластеризация системы расселения Цель задания — освоение методов кластеризации и регионизации точек, построения центроидов и оценки качества кластеризации. В качестве метода кластеризации предлагается использовать DBSCAN. В качестве метода построения региона — альфа-оболочку. Исходные данные: точки населенных пунктов из Самостоятельной работы №1. Изучение работы методов кластеризации и регионизации На данном этапе необходимо изучить принципы работы метода кластеризации DBSCAN, построения альфа-оболочки и центроида полигона: Метод DBSCAN доступен в виде инструмента Python, приложенного к данному заданию. Метод альфа-оболочки доступен в инструменте Cartography Tools &gt; Generalization &gt; Aggregate Points. Центроид полигона можно получить посредством применения инструмента Data Management Tools &gt; Features &gt; Feature to Polygon. Меняя параметры инструментов (расстояния, количество точек), ознакомьтесь с тем, как это влияет на получаемый результат. Оболочки, как и кластеры стройте для набора данных test. Автоматизация выделения регионов и центроидов кластеров Необходимо создать инструмент Python Toolbox, который будет принимать на вход слой маркированных точек и выдавать класс пространственных объектов с альфа-оболочками каждого кластера, а также центроидами кластеров Параметры инструмента: Входной слой точек (Input points) Название поля, в котором хранятся марки кластеров (Cluster ID Field) Расстояние кластеризации (Сluster distance) Выходной слой альфа-оболочек (Output regions feature class) Выходной слой центроидов (Output centroids feature class) Требования к результатам: Каждый регион должен соответствовать своему кластеру и содержать в качестве атрибутов исходный идентификатор и количество точек, входящих в данный кластер. Центроиды кластеров должны быть получены методом Inside (внутри) Рекомендации по выполнению: Создайте пустой полигональный классы пространственных объектов для выходных полигонов (CreateFeatureclass_management(...)). Извлеките все значения поля, хранящего идентификаторы кластеров в список, используя arcpy.da.SearchCursor(...). Преобразуйте полeченный список в множество (set(...)), чтобы оставить в нем только уникальные значения. Создайте слой для входного класса объектов точек (MakeFeatureLayer_management(...)). Организуйте цикл по элементам полученного на шаге 3 множества. Выберите точки, номер кластера которых совпадает с переменной цикла — текущим номером кластера (SelectLayerByAttribute_management). Для выбранных точек запустите процедуру регионизации (AggregatePoints_cartography). В качестве расстояния кластеризации необходимо указывать удвоенное расстояние, использованное ранее в методе DBSCAN. В этом случае оболочки будут соответствовать исходным кластерам. Для полученных регионов кластеров необходимо выполнить операцию объединения (Dissolve), так как они могут состоять из нескольких оболочек, касающихся в одной точке. Рассчитайте количество точек в текущем кластере и запишите его в поле Count текущего полигона. Добавьте текущий полигон в выходной полигональный класс. После выполнения цикла конвертируйте полигоны в выходные точки центроидов (FeatureToPoint_management). Автоматизация расчета критериев качества кластеризации Необходимо самостоятельно реализовать инструмент, который рассчитывает критерии качества кластеризации: среднее внутрикластерное и межкластерное расстояния, а также их соотношение. Для реализации инструмента необходимо с помощью arcpy.da.SearchCursor прочесть координаты и номера кластеров всех точек, рассчитать все попарные расстояния между ними и далее агрегировать полученную информацию в виде искомых показателей. Результирующие значения выводятся в лог инструмента посредством arcpy.AddMessage(...). Кластеризация системы расселения субъекта Cпроецируйте исходные данные в проекцию, оптимальную для выбранного региона. Используя созданный инструмент, постройте серию из 5 кластеризаций населенных пунктов выбранного вами субъекта. Количество точек в кластере оставьте постоянным (3), но меняйте значение расстояния кластеризации. Расстояния подберите таким образом, чтобы различия в кластеризации были очевидны и помогали выявлять пространственные группировки разного масштаба. Рассчитайте для каждой кластеризации меры качества: среднее внутрикластерное и межкластерное расстояние, их отношение. Сведите их в таблицу. Для каждого уровня кластеризации подготовьте изображение, включающее: а) исходные точки, б) регионы кластеров, в) центроиды кластеров. Точки и регионы должны быть помечены разными цветами по номерам кластеров. Центроиды должны быть показаны окружностями радиуса, пропорционального количеству входящих точек. Пример изображения кластеров: Рис. B.1: Пример оформления результатов работы Перед вставкой данных карт в отчет добавьте на них элементы географической основы или используйте карту-подложку в виде картографического веб-сервиса. Отчет Напишите отчет о проделанной работе, включающий: Цель и задачи работы. Описание алгоритмов DBSCAN, построения альфа-оболочки и центроида полигона. Описание процесса создания скриптов для выделения регионов и центроидов кластеров, а также расчета критериев качества кластеризации. Серию из 5 карт кластерной структуры системы расселения региона, полученную по результатам кластеризации. Анализ качества кластеризации (согласно рассчитанным критериям). Географический анализ результатов. Насколько реалистично выглядят полученные кластеры, к чему они привязаны? Можно ли выявить полимасштабность организации системы расселения на основе полученных изображений? "],["lines-simpl-work.html", "C Задание №3. Геометрическое упрощение линий C.1 Теоретические сведения Часть 1. Автоматизация метода Ли-Оупеншоу Часть 2. Автоматизация методов оценки геометрической точности и коэффициента относительной извилистости Часть 3. Сравнение алгоритмов Ли-Оупеншоу, Ванга-Мюллера, Дугласа-Пейкера и Висвалингам-Уайатта", " C Задание №3. Геометрическое упрощение линий Цель задания — освоение методики геометрического упрощения линий. Аннотация. Необходимо реализовать метод Ли-Оупеншоу для генерализации линий. Для этого на языке программирования Python создается инструмент Python Toolbox, осуществляющий последовательный запуск инструментов ArcToolbox. Помимо этого релаизуются инструменты для вычисления коэффициента относительной извилистости и модифицированного расстояния Хаусдорфа. После создания инструмента необходимо сравнить результаты работы алгоритма с тем, что получается при обработке линий посредством алгоритма Дугласа-Пейкера, Ванга-Мюллера и Висвалингам-Уайатта. Задание выполняется в ГИС-пакете ArcGIS. C.1 Теоретические сведения C.1.1 Алгоритмы генерализации Алгоритм Ли-Оупеншоу (Li and Openshaw 1992) использует «естественный принцип», суть которого заключается в удалении деталей, размер которых менее видимой величины. Для этого на исходное множество линий накладывается регулярная сет ка ячеек с разрешением d Участок линии, пересекающий ячейку, имеет точку входа в нее и точку выхода. Этот участок заменяется на середину отрезка, соединяющего две данные точки. Таким образом, удаляются все изгибы, находящиеся внутри ячеек. Принцип работы алгоритма иллюстрирует Рис. C.1. Видно, что по своему поведению результирующая линия похожа на скользящее среднее. Рис. C.1: Принцип работы алгоритма Ли-Оупеншоу В основе работы алгоритма Ванга-Мюллера (Wang and Müller 1998) лежит сегментация линий на отдельные изгибы. Изгиб определяется как участок линии, на котором угол ее поворота сохраняет свой знак. Важным аспектом алгоритма является четкий алгоритм вычисления вершины изгиба, которая определяется как точка, имеющая максимальную сумму расстояний до начальной и конечной точки изгиба. Для каждого изгиба в алгоритме Ванга-Мюллера определяется его размер, изолированность, близость и схожесть с соседним изгибом. Изолированные изгибы подвергаются преувеличению. Расположенные рядом схожие изгибы объединяются в один путем слияния вершин и удаления изгиба между ними. Наконец, изгибы малого размера удаляются. Данные операции проиллюстрированы на Рис. C.2. В ArcGIS метод Ванга-Мюллера реализован в инструменте Simplify Line (режим BEND_SIMPLIFY). Рис. C.2: Элементы алгоритма Ванга-Мюллера: а) удаление; б) объединение; в) преувеличение изгибов Алгоритм Дугласа-Пейкера (Douglas and Peucker 1973) относится к алгоритмам редуцирования точек и основан на последовательном нахождении узлов линии, образующих максимальное отклонение от стягивающей хорды (Рис. C.3). В ArcGIS метод Дугласа-Пейкера реализован в инструменте Simplify Line (режим POINT_REMOVE). Рис. C.3: Принцип работы алгоритма Дугласа-Пейкера Наконец, алгоритм Висвалингам-Уайатта (Visvalingam and Whyatt 1993) относится к алгоритмам редуцирования точек и основан на последовательном удалении точек, углы которых образуют минимальную эффективную площадь (Рис. C.4). В ArcGIS данный алгоритм представлен в модификации Жу и Джонса (Zhou and Jones 2005), где каждая площадь приобретает различный вес в зависимости от пропорций угла линии и реализован в инструменте Simplify Line (режим WEIGHTED_AREA). Рис. C.4: Принцип работы алгоритма Висвалингам-Уайатта C.1.2 Модифицированное расстояние Хаусдорфа Модифицированное расстояние Хаусдорфа (MHD), широко используется как метрика оценки геометрической точности линий. Пусть даны два множества точек \\(\\mathcal{A} = \\lbrace a_1,...,a_{N_a} \\rbrace\\) и \\(\\mathcal{B} = \\lbrace b_1,...,b_{N_b} \\rbrace\\). Тогда среднее расстояние между \\(\\mathcal{A}\\) и \\(\\mathcal{B}\\) может быть вычислено как \\(\\overline{d}(\\mathcal{A},\\mathcal{B}) = \\frac{1}{N_a}\\sum_{a \\in \\mathcal{A}}d(a,\\mathcal{B})\\), где \\(d(a, \\mathcal{B}) = \\min_{b \\in \\mathcal{B}}\\lVert a - b \\rVert\\). Аналогично, обратное расстояние между \\(\\mathcal{B}\\) и \\(\\mathcal{A}\\) вычисляется как \\(\\overline{d}(\\mathcal{B},\\mathcal{A}) = \\frac{1}{N_b}\\sum_{b \\in \\mathcal{B}}d(b,\\mathcal{A})\\), где \\(d(b, \\mathcal{A}) = \\min_{a \\in \\mathcal{A}}\\lVert b - a \\rVert\\). Имея прямое и обратное расстоения между \\(\\mathcal{A}\\) и \\(\\mathcal{B}\\), модифицированное расстояние Хаусдорфа MHD вычисляется как: \\[ MHD(\\mathcal{A}, \\mathcal{B}) = max\\big(\\overline{d}(\\mathcal{A},\\mathcal{B}), \\overline{d}(\\mathcal{B},\\mathcal{A})\\big), \\] Грубо говоря, MHD есть есть максимальное из средних расстояний от \\(\\mathcal{A}\\) к \\(\\mathcal{B}\\) и от \\(\\mathcal{B}\\) к \\(\\mathcal{A}\\). Чем меньше значение MHD, тем интегрально ближе \\(\\mathcal{A}\\) и \\(\\mathcal{B}\\) друг к другу. Введение этой метрики вдохновлено классическим расстоянием Хаусдорфа (в котором \\(d(\\mathcal{A},\\mathcal{B}) = max_{a \\in \\mathcal{A}} d(a,\\mathcal{B})\\)), которое, как видно из определения, чувствительно к точкам-выбросам, поскольку использует максимальное расстояние вместо среднего. При оценке геометрической точности в качестве множеств \\(\\mathcal{A}\\) и \\(\\mathcal{B}\\) используются ребра исходного и генерализованного множеств линий соответственно. C.1.3 Коэффициент относительной извилистости Коэффициент извилистости — мера извилистости объекта, вычисляемая как отношение длины линии к длине отрезка, соединяющего ее концы. Пусть линия \\(L\\) состоит из \\(n\\) узлов, соединенных ребрами. Тогда коэффициент ее извилистости будет равен: \\[K = \\frac{\\sum_{i=1}^{n-1} l_{i, i+1}}{l_{1,n}}\\] где \\(l_{i,k}\\) — Евклидово расстояние между i-м и k-м узлом линии. Коэффициент извилистости зависит от конфигурации сглаживающей, описывающей общую траекторию линии. В предельном случае, когда имеют дело с замкнутой фигурой, величина \\(К\\) не определена, т.к. длина стягивающей хорды равняется нулю. Чтобы избежать этого, можно вычислить отношение длины линии не к стягивающей, а к сглаживающей, т.е. вычислить относительную извилистость. Для этого можно сегментировать линию одним из двух способов: либо сдвигаться на одинаковое значение стягивающей хорды, либо сдвигаться вдоль самой линии с равным шагом. Второй подход вычислительно более эффективен, так как он не требует поиска пересечения с окружностью, а также поиска следующей по ходу линии точки (пересечений может быть несколько в случае извилистой линии). Коэффициент относительной извилистости, вычисляемый при таком подходе, имеет следующий вид: \\[\\overline{K} = \\frac{\\sum_{j=1}^{m} K_j}{m}\\] где \\(K_j\\) — коэффициент извилистости для \\(k\\)-го сегмента линии, \\(m\\) — число сегментов. Рис. C.5: Подходы к вычислению коэффициента относительной извилистости: а) с фиксированной длиной стягивающей хорды; б) с фиксированной длиной сегмента линии При вычислении относительной извилистости средствами ГИС разбиение линии на сегменты можно заменить разрезанием линии регулярной сеткой ячеек. В этом случае коэффициент \\(K_j\\) будет вычисляться для сегмента линии, попавшего в \\(j\\)-й квадрат. Часть 1. Автоматизация метода Ли-Оупеншоу Создайте базу геоданных для результатов генерализации и назначьте ее базой данных по умолчанию для размещения результатов пространственного анализа. Проделайте следующую последовательность операций (жирным шрифтом указаны названия инструментов): Постройте вокруг исходных линий буфер (Buffer), размер которого равен разрешению генерализации (3000 м). В качестве исходных линий используйте слой Island в базе геоданных Test. Создать сетку (Create Fishnet). В качестве образца экстента используйте полученный буфер. Для тестирования используйте размер сетки 3000 м. Тип сетки должен быть полигональный. Найти пересечение сетки и исходных линий (Identity). Cлоем источника должен быть слой генерализуемых линий. Слоем Identity — сетка. Превратить линии из составных в обычные (Multipart to Singlepart). Найти точки линий, лежащие на границах ячеек (Feature Vertices to Points, режим BOTH_ENDS). Восстановить отрезки, соединяющие эти точки (Points to Line), используя идентификатор отрезка (ORIG_FID). Найти середины отрезков, полученных на шаге e) (Feature Vertices to Points, режим MIDPOINT). Восстановить линию из отрезков, полученных на шаге е) (Unsplit Line). Разрезать эту линию серединами, полученными на шаге f) (Split Line At Point, допуск по расстоянию 100 м). Превратить разрезанные линии из составных в обычные (Multipart to Singlepart). Найти конечные точки полученных сегментов линий (Feature Vertices to Points, режим BOTH_ENDS). Восстановить отрезки, соединяющие эти точки (Points to Line), используя идентификатор отрезка ORIG_FID. Восстановить линию из отрезков (Unsplit Line). Примечание: шаги g) – j) нужны для того, чтобы середины соседних отрезков, полученные на шаге f) приобрели общий идентификатор для их соединения. Создайте набор инструментов Python Toolbox “Line Simplification”. Реализуйте последовательность действий, выполненную на шаге 2, в виде инструмента геообработки LiOpenshaw. Вынесите в качестве параметров инструмента следующие объекты: Входной слой линий Разрешение сетки по X Разрешение сетки по Y Экстент сетки Выходной слой линий Убедитесь, что для остальных параметров в инструмента стоит опция Intermediate (промежуточный). Протестируйте инструмент на слое Island, используя разное разрешение (2-10 км) Изложите ваш опыт создания инструмента в отчете, включая интерпретацию метода Ли-Оупеншоу в терминах инструмента геообработки, процесс создания инструмента и оформления его параметров. Проиллюстрируйте текст снимками экрана. Часть 2. Автоматизация методов оценки геометрической точности и коэффициента относительной извилистости Автоматизация вычисления модифицрованного Хаусдорфова расстояния MHD (оценка геометрической точности) Инструмент Python Toolbox Modified Hausdorff Distance должty включать следующие этапы. Конвертируйте исходную линию в точки (Feature vertices to points). Добавьте в таблицу поле ID, запишите в него значение OBJECTID (Add Field, Calculate Field) Добавьте в таблицу поле Sort, запишите в него значение 0 (Add Field, Calculate Field). Это будут начальные точки векторов смещения. Вычислите расстояние от полученных точек до генерализованной линии (Near, с установленной опцией Location). Помимо расстояний, полученный слой будет содержать также координаты ближайшей точки. Конвертируйте таблицу в точечный слой на основе полученных координат (Make XY Event Layer). Это будут конечные точки векторов смещения. Замените значения поля Sort в полученном слое на 1 (Calculate Field). Добавьте содержимое полученного слоя к точечному классу, содержащему исходные точки (Append). Конвертируйте полученные точки в линии векторов смещения (Points to Line). В качестве Line Field используйте поле ID, в качестве Sort Field – поле Sort. Визуализируйте полученный слой стрелками как на Рис. C.6. Рис. C.6: Пример визуализации векторов смещения линии Вычислите среднее расстояние от исходной линии до генерализованной путем осреднения поля Shape_Length (Summary Statistics) Вычислите аналогичным образом обратное расстояние (для этого потребуется генерализованную линию превратить в точки). Получите Модифицированное Хаусдорфово расстояние путем нахождения максимума из полученных значений (Calculate Value). Чтобы извлечь значения, используйте функцию Get Field Value. Инструмент должен включать следующие параметры: Исходные линии Генерализованные линии Выходной класс векторов смещения Автоматизация вычисления коэффициента относительной извилистости (оценка морфологического соответствия) Создайте новый инструемнт Python Toolbox Sinuosity, модифицировав инструмент генерализации, созданный ранее для алгоритма Ли-Оупеншоу. Вам необходимо внутри каждого квадрата поделить длину исходной линии на длину отрезка, соединяющего точки пересечения с линиями сетки. А затем посчитать среднее из полученных значений (Summary Statistics). Отчет Опишите ваш опыт разработки инструментов оценки геометрической точности и морфологического соответствия для линий. Сопроводите данный раздел отчета снимками экрана и примерами получаемых результатов Часть 3. Сравнение алгоритмов Ли-Оупеншоу, Ванга-Мюллера, Дугласа-Пейкера и Висвалингам-Уайатта Сравните результаты работы вашего инструмента и инструмента Simplify Line в режимах BEND_SIMPLIFY (алгоритм Ванга-Мюллера), POINT_REMOVE (алгоритм Дугласа-Пейкера) и WEIGHTED_AREA (алгоритм Висвалингам-Уайатта). Используя шаг сетки, равный 2 мм в результирующем масштабе (1:4 000 000), упростите линию с помощью метода Ли-Оупеншоу. Подберите параметры алгоритмов Дугласа-Пейкера, Ванга-Мюллера и Висвалингам-Уайатта таким образом, чтобы количество результирующих точек в линиях было примерно равно (±5%) количеству точек после генерализации методом Ли-Оупеншоу. Выпишите эти параметры в отчет. Для подсчета количества точек используйте инструмент Feature Vertices to Points Рассчитайте модифицированное Хаусдорфово расстояние от оригинальной линии для четырех полученных результатов генерализации Рассчитайте коэффициент относительной извилистости в исходном и результирующем масштабе, используя шаг сетки 5-7 мм в масштабе карты. Сведите в одну таблицу параметры инструментов, а также рассчитанные величины MHD и коэффициента относительной извилистости по каждому алгоритму. Оцените алгоритмы по следующим критериям: При каких параметрах инструментов количество результирующих узлов линий одинаково? Модоифицированное хаусдорфово расстояние. Насколько эффективно алгоритм использует точки? Какой из алгоритмов дает контур, наиболее близко повторяющий исходную кривую? Относительная извилистость. Насколько сглаженным/угловатым получается изображение? Какой из алгоритмов дает значение извилистости более близкое к оригиналу? Какой метод на ваш взгляд дает наиболее удовлетворительные результаты с точки зрения принципов картографической генерализации и лучше передает морфологию объектов? Сделайте для отчета 4 иллюстрации с мини-легендой, на каждой из которых показан исходный контур и поверх — его генерализованная версия (по иллюстрации на каждый алгоритм). Разные алгоритмы выделите разными цветами. Изложите в отчете свой опыт сравнительного анализа алгоритмов генерализации. References "],["lines-network-work.html", "D Задание №4. Отбор элементов транспортной сети Часть 1. Подготовка исходных данных Часть 2. Создание инструмента геообработки Python Toolbox для отбора элементов транспортной сети Часть 3. Создание инструента Python Toolbox для оценки относительной графической нагрузки по линейным объектам Часть 4. Создание и анализ карты транспортной связности районных центров субъекта", " D Задание №4. Отбор элементов транспортной сети Цель задания — освоение методики отбора элементов транспортных сетей с использованием алгоритмов на графах Аннотация. Задание посвящено знакомству с методикой автоматизированного отбора дорог для мелкомасштабного картографирования. Необходимо реализовать алгоритм прореживания транспортной сети (отбора линий), основанный на принципе маршрутной связности населенных пунктов. Дополнительно реализуется расчет условной графической нагрузки для линий. Задание выполняется путем разработки инструмента геообработки Python Toolbox с модулем Network Analyst (arcpy.na). Предлагаемый для реализации алгоритм основан на предположении, что в результирующем масштабе необходимо показывать транспортные пути, по которым проходят кратчайшие маршруты между соседними населенными пунктами. Понятие соседства при решении этой задачи может быть формализовано разоличными способами: по количеству (Samsonov and Krivosheina 2012), либо по смежности (Schmid and Janatzek 2013). В настоящей работе используется соседство по смежности: соседними считаются населенные пункты, у которых соприкасаются ячейки Вороного. Общая схема алгоритма выглядит следующим обазом: Строится граф дорожной сети. Строится диаграмма Вороного населенных пунктов. Организуется цикл по точкам населенных пунктов: выбирается текущая точка (центральная); выбирается относящаяся к текущей точке ячейка Вороного; для выбранной ячейки выбираются смежные с ней (касающиеся по границе); выбираются соответствующие соседним ячейкам точки населенных пунктов; от каждой соседней точки строится маршрут до центральной точки (решается задача Closest Facility) линии, по которым прошли маршруты, помечаются флагом. В результате выполнения алгоритма все транспортные пути, которые оказались задействованы в кратчайших маршрутах, будут помечены специальным флагом. Генерализация завершается исключением непомеченных линий (физическое удаление не требуется, достаточно выполнить атрибутивный запрос). Часть 1. Подготовка исходных данных Выберите регион для выполнения задания и скопируйте себе соответствующую базу данных из архива приложенного к данному заданию. Добавьте в исходный слой линий (rdslin) целочисленное поле Show, которое будет заполняться флагом отбора. Добавьте в исходный слой населенных пунктов (poppnt) целочисленное статуса Status, которое будет хранить роль населенного пункта в процессе отбора элементов транспортной сети. Заполните это поле следующим образом: единица (\\(1\\)) должна стоять у населенных пунктов, располагающихся внутри выбранного субъекта и имеющих статус не ниже райцентра, двойка (\\(2\\)) должна стоять у всех населенных пунктов, располагающихся за пределами субъекта. Все остальные населенные пункты (располагающиеся внутри субъекта, но имеющие статус ниже райцентра) должны иметь значение \\(0\\). Создайте набор пространственных объектов (Feature Dataset) внутри базы геоданных и импортируйте в него слой дорожной сети. Создайте в слое дорог новое целочисленное поле Hierarchy и заполните его значениями: 1 — для автомагистралей и усовершенствованных шоссе 2 — для шоссе 3 — для всех прочих дорог Внутри набора пространственных объектов создайте набор сетевых данных (Network Dataset), используя слой rdslin. Все параметры оставьте по умолчанию, за исключением: Elevation Fields — None Driving Directions — None Attributes: добавить новый атрибут типа Hierarchy (Add). Далее добавить для него оценщика (Evaluators), указать, что оценку необходимо делать по полю Hierarchy. Часть 2. Создание инструмента геообработки Python Toolbox для отбора элементов транспортной сети В качестве входных данных необходимо предусмотреть 5 слоев: исходные точки (Input Points), исходные линии (Input Lines), набор сетевых данных (Input Network Dataset) поле статуса (Status Field) поле видимости (Show Field) По результатам выполнения инструмента в поле Show Field должно быть проставлено значение \\(1\\) для отобранных линий. Все остальные линии должны иметь значение \\(0\\). Реализуйте скрипт геообработки в соответствии со следующей последовательностью действий: Создать слой линий (Create Feature Layer). Создать слой точек (Create Feature Layer), оставив в нем только точки, со статусом выше \\(0\\) (используйте параметр where_clause) Создать диаграмму Вороного для полученного слоя точек (Create Thiessen Polygons). Разместите диаграмму в памяти компьютера (in_memory\\voronoy). Создать слой диаграммы Вороного (Create Feature Layer). Создать поисковый курсор (rows = arcpy.da.SearchCursor(...)) для последовательного обхода ячеек диаграммы Вороного (1), оставив в нем только поле статуса и поле геометрии. Организовать цикл по строкам созданного курсора (for row in rows:). Все дальнейшие операции выполняются внутри цикла. Если текущая ячейка имеет статус \\(2\\), перейти на следующую итерацию цикла. Создать на основе сетевого набора данных слой поиска ближайших пунктов обслуживания (Make Closest Facility Layer). В качестве параметра Number of Facilities to Find оставьте 1. Установите режим движения TRAVEL_FROM. Выбрать точку населенного пункта геометрией объекта текущей строки курсора (row[1], если геометрическое поле указано вторым по порядку), используя правило WITHIN (Select By Location). Добавить в слой поиска выбранную точку (Add Locations в режиме Facilities). Выбрать с помощью геометрии текущего полигона (row[1]) его соседей, используя правило (Select By Location). Выбрать в слое точек с помощью выбранных полигонов, используя правило INTERSECT (Select By Location). Добавить в слой поиска ближайших пунктов обслуживания точки соседей (Add Locations в режиме Incidents) Очистить выборку в слое диаграммы Вороного (Select By Attributes в режиме CLEAR\\_SELECTION). Очистить выборку в слое точек (Select By Attributes в режиме CLEAR\\_SELECTION). Запустить расчет задачи Closest Facility (Solve) Извлечь линии маршрутов Routes (Select Data) из полученного слоя. Выбрать линии в слое дорог маршрутами (Select By Location), используя правило SHARE_A_LINE_SEGMENT_WITH. Вычислить поле Show Field для выбранных линий 2, используя калькулятор поля (Calculate Field). Проставить выделенным линиям значение 1. Очистить выборку в слое линий. (Select By Attributes в режиме CLEAR_SELECTION). Удалить слой Closest Facility (Delete). Часть 3. Создание инструента Python Toolbox для оценки относительной графической нагрузки по линейным объектам Используя имеющиеся у вас знания и навыки, создайте скрипт Python Toolbox, который будет давать оценку относительной графической нагрузки для линейных объектов по ячейкам регулярной сети. Относительная графическая нагрузка по линейным объектам – суммарная длина линий каждого класса (Lk) с учетом весовых коэффициентов (wk), деленная на площадь ячейки (A): \\[\\rho_{L} = \\frac{\\sum_{k}^{}{w_{k}L_{k}}}{A}\\] Числитель формулы имеет единицы измерения на местности (км). Знаменатель выражен в единицах измерения карты (\\(см^2\\)). Применительно к линейным объектам относительная графическая нагрузка является аналогом густоты, и также выражается в относительных единицах (\\(км/см^2\\)), но учитывает толщину линий в качестве весовых коэффициентов \\(w\\), чтобы придать большую нагрузку ячейкам, где проходят линии высоких классов. Веса \\(w\\) должны быть прямо пропорциональны толщинам линий (или равны им). Входные параметры: Линейный слой Поле Size Field, отвечающее за графический вес линии (толщина линии в миллиметрах). Пространственное разрешение сетки (в сантиметрах изображения). Масштаб изображения Требования к результату: Результатом выполнения инструмента должен быть полигональный слой c ячейками регулярной сети, для каждой из которой в поле Load записана относительная графическая нагрузка, рассчитанная по вышеприведенной формуле. Указания к выполнению: В качестве отправной точки можно использовать инструмент геообработки для оценки относительной графической нагрузки точечных объектов, разработанный вами в Самостоятельной работе №1. В процессе экспериментальной работы используйте следующие толщины линий (в пикселах): Таблица D.1: Параметры толщины линии Класс Толщина линии 1 4 2 2 3 1 Часть 4. Создание и анализ карты транспортной связности районных центров субъекта Используя разработанные инструменты отбора и оценки графической нагрузки, выполните заключительную часть работы: Выполните отбор элементов дорожной сети, проходящих через районные центры выбранного субъекта. Оформите результат в виде карты масштаба 1:8 000 000. Используйте толщины линий 3, 1.5 и 0.75 пункта соответственно. На схеме должны быть подписаны все районные центры внутри и за пределами субъекта, нанесена граница субъекта и оформлена легенда по трем классам дорог. Вычислите условную графическую нагрузку всех исходных дорог в масштабе 1:1 000 000 (размер квадрата 2х2 см в масштабе карты). Используйте толщины линий 6, 3 и 1.5 пункта соответственно. Оформите картограмму графической нагрузки в масштабе 1:8 000 000. Вычислите условную графическую нагрузку отобранных дорог в масштабе 1:8 000 000 (размер квадрата 2х2 см в масштабе карты). Используйте толщины линий 3, 1.5 и 0.75 пункта соответственно. Оформите картограмму графической нагрузки в масштабе 1:8 000 000. Напишите отчет о проделанной работе, включающий: Описание целей и задач самостоятельной работы Описание идеи алгоритмов отбора элементов дорожной сети и оценки условной графической нагрузки для линейных объектов Процесс создания инструментов геообработки и их внешний вид Процесс экспериментальной работы Оценку полученных результатов с точки зрения географической достоверности. Оценка должна включать сравнение исходной и результирующей картины транспортной сети региона визуально и по картограмме условной графической нагрузки. References "],["polygons-skeleton-work.html", "E Задание №5. Скелетизация площадных объектов гидрографии Часть 1. Подготовка входных данных Часть 2. Автоматизация построения скелета фигуры Часть 3. Построение сетевой модели данных Часть 4. Автоматизация построения срединной оси фигуры Часть 5. Построение срединной оси и описание результатов", " E Задание №5. Скелетизация площадных объектов гидрографии Цель задания — освоение методики скелетизации площадных пространственных объектов на примере построения срединной оси водоема. Часть 1. Подготовка входных данных Выбрать одно из следующих водохранилищ: Куйбышевское, Камское, Братское, Горьковское. Обрезать набор данных (водохранилище + примыкающие к нему реки) с небольшим запасом. Трансформировать данные в оптимальную проекцию. Часть 2. Автоматизация построения скелета фигуры Данный инструмент геообработки (Voronoy Skeleton) должен строить скелет полигонального объекта на основе диаграммы Вороного (Рис. E.1): Рис. E.1: Скелет полигонального объекта Входные параметры: Полигональный класс пространственных объектов. Расстояние уплотнения вершин (по умолчанию 1000 метров). Выходной класс линейных пространственных объектов. Последовательность действий: Выполнить уплотнение вершин полигона с шагом 1 км (Densify). Конвертировать вершины полигона в точки (Feature Vertices To Points). Построить для точек диаграмму Вороного (Create Thiessen Polygons). Конвертировать полигоны Вороного в линии (Polygon to Line). Создать слой пространственных объектов (Make Feature Layer). Выделить линии, не находящиеся целиком внутри полигона (Select Layer By Location в режиме COMPLETELY_WITHIN). Удалить выделенные линии (Delete Features). Часть 3. Построение сетевой модели данных С использованием полученной на предыдущем этапе модели геообработки постройте скелет выбранного вами водохранилища. На основе полученного скелета создайте сетевой набор данных (Network Dataset). Выполните сборку сетевого набора данных (Build Network Dataset). Часть 4. Автоматизация построения срединной оси фигуры Данный инструмент геообработки (Medial Axis Connectivity) должен на основе скелета фигуры (преобразованного в сетевую модель) и примыкающих линий водотоков получать срединную ось, связывающую точки их впадения/истока (Рис. E.2): Рис. E.2: Срединная ось площадного объекта Входные параметры: Входной сетевой набор данных (скелет). Входной линейный слой (реки). Входной полигональный слой (озера/вдхр). Расстояние поиска (используется для локализации точек на сетевой модели), по умолчанию равно 2000 м. Среда притягивания (используется для притягивания концов построенных маршрутов к линиям рек). Расстояние так же по умолчанию равно 2000 м. Выходной класс линейных пространственных объектов. Последовательность действий: Создать слой задачи поиска ближайшего пункта обслуживания (Make Closest Facility Analysis Layer). Конвертировать линии гидрографии (параметр 2) в конечные вершины (Feature Vertices to Points). Создать слой пространственных объектов (Make Feature Layer). Выделить вершины, не пересекаемые площадным объектом гидрографии (параметр 3) (Select Layer By Location). Удалить выделенные вершины (Delete Features). Извлечь идентификатор OBJECTID для первой точки (Get Field Value). Выбрать первую точку по атрибуту OBJECTID, используя полученное на шаге 6 значение (Select Layer by Attribute). Добавить выбранную точку в слой 1 в качестве пункта обслуживания (Add Locations — Facilities). Инвертировать выборку 7 (Select Layer by Attribute). Добавить выбранные точки в слой 1 в качестве событий (Add Locations — Incidents). Решить задачу поиска ближайшего пункта обслуживания (Solve). Выбрать линии маршрутов (Select Data — Routes). Вычислить пересечения внутри слоя маршрутов (Intersect). Вырезать полученными линиями участки в маршрутах 12 (Erase). Объединить слои 13 и 14 (Merge) в выходной класс линейных пространственных объектов. Осуществить притягивание маршрутов к концам линий рек (Snap — END), используя параметр 5 (туда так же подается слой рек). Часть 5. Построение срединной оси и описание результатов Используя разработанный на предыдущем этапе инструмент геообработки и полученную ранее сетевую модель скелета, выполните построение срединной оси выбранного водохранилища. Оформите полученные результаты в виде карты с двумя изображениями (лево-право): исходные данные, результат генерализации. Добавьте на карту подложку из картографическогоо сервиса (можноо использовать OpenStreetMap) Напишите отчет о проделанной работе, включающий: Цель и задачи работы. Описание сути изучаемого метода генерализации площадных объектов гидрографии, примеры случаев, когда это бывает необходимо. Процесс создания моделей геообработки и их внешний вид. Процесс экспериментальной работы, включая снимки экрана промежуточных результатов. Итоговые карты. Оценку полученных результатов с точки зрения географической достоверности. "],["ex-dem.html", "F Задание №6. Генерализация цифровой модели рельефа F.1 Подготовка исходных данных F.2 Автоматизация итерационного сглаживания ЦМР F.3 Сравнение структурной генерализации и глобальной фильтрации ЦМР", " F Задание №6. Генерализация цифровой модели рельефа Цель задания — овладение различными техниками генерализации ЦМР. В настоящем задании необходимо сравнить два метода мелкомасштабной генерализации ЦМР: глобальная фильтрация и структурная генерализация. Задачи работы включают подготовку исходных данных, разработку программного инструмента итерационного сглаживания ЦМР, выполнение генерализации ЦМР методами структурной генерализации и глобальной фильтрации, а также сравнительный анализ полученных результатов F.1 Подготовка исходных данных Закачайте набор инструментов DEM Generalization и разархивируйте его: Рис. F.1: Инструмент генерализации ЦМР DEM Generalization Закачайте фрагмент ЦМР GEBCO 2021 размером \\(10^\\circ \\times 10^\\circ\\), используя веб-интерфейс. Для этого включите показ градусной сетки (Show graticule), выберите формат GeoTIFF и, используя CTRL + клик, обведите квадрат со сторонами, примерно совпадающими с линиями сетки, кратными 5 градусам: Рис. F.2: Загрузка цифровой модели рельефа GEBCO На выбор предлагаются фрагменты с центрами в следующих точках: Красное море (\\(40; 15\\)); Альпы (\\(10; 45\\)); Норвегия (\\(10; 60\\)); Южный Каспий (\\(50; 40\\)); Центральные Анды (\\(-70; -15\\)); Северные Анды (\\(-75; 5\\)); Аляска (\\(-150; 60\\)); Камчатка (\\(160; 55\\)); Австралия (\\(150; -35\\)); Калифорния (\\(-120; 35\\)) Закачайте данные Natural Earth масштаба 1:10 000 000 для следующих слоев: береговая линия (Coastline); океан (Ocean); гидрография площадная (Rivers + lake centerlines); гидрография линейная (Lakes + Reservoirs) Получите охват скачанного растра в качестве полигона (Raster Domain). Обрежьте полученным полигоном данные Natural Earth (Clip). Перепроецируйте все исходные данные (ЦМР + три векторных слоя) в цилиндрическую равнопромежуточную проекцию World_Plate_Carree. Если операция выполнена верно, то проецированная версия ЦМР должна в точности совпадать с исходной как по размерам, так и по значениям. Отличие будет заключаться только в координатах ячеек, которые от градусов перейдут в метрические. F.2 Автоматизация итерационного сглаживания ЦМР В данной части задания необходимо создать набор инструментов Python Toolbox, содержащий один инструмент Iterate Focal Statistics, который выполняет последовательное сглаживание цифровой модели рельефа фильтром среднего в несколько проходов с использованием заданных параметров. Предварительное чтение: Синтаксис вызова инструмента Focal Statistics средствами языка программирования Python. Создание нового набора инструментов Python Toolbox. Параметры инструмента: Входная ЦМР (Input Raster DEM). Размер плавающего окна (Filter size). Количество итераций (Number of iterations). Выходная ЦМР (Output Raster DEM). Указания к выполнению: Скачайте шаблон инструмента Python Toolbox. Переименуйте шаблон в Ex6.pyt. Модифицируйте шаблон, дав основному инструменту название Iterate Focal Statistics и определив в нем необходимые параметры и их типы. Добавьте строку импорта функций модуля Spatial Analyst: from arcpy.sa import *. Выполните редактирование функции execute(), включив в нее следующие шаги (вместо многоточия подставьте нужные параметры): Чтение параметров инструмента в теле функции. Например: in_raster = parameters[0].valueAsText. Создание объекта типа Raster из слоя входной ЦМР: dem = Raster(...). Создание прямоугольной окрестности заданного размера: nbr = NbrRectangle(...). Организация цикла от \\(0\\) до \\(N-1\\), где \\(N\\) — количество итераций, переданное в качестве параметра инструмента: for i in range(N):. Внутри цикла: Вывод сообщения о текущем номере итерации: arcpy.AddMessage(...). Вызов функции фокальной статистики с созданной ранее окрестностью. Чтобы на каждой итерации на вход подавался результат выполнения предыдущей итерации, просто записывайте его в ту же переменную: dem = FocalStatistics(dem, ...). Сохранение полученного растра в выходной набор данных Output Raster DEM: dem.save(...). F.3 Сравнение структурной генерализации и глобальной фильтрации ЦМР В данной части задания необходимо выполнить генерализацию фрагмента глобальной ЦМР двумя методами: структурная генерализация и глобальная фильтрация. Выполните генерализацию ЦМР с использованием инструмента Generalize DEM, указав слой ocean в качестве параметра Marine area polygon feature layer. Для начала выполните генерализацию со стандартными параметрами, после этого включите сглаживание ЦМР в блоке Widening and Smoothing и усильте генерализационный эффект в блоке Main parameters таким образом чтобы результирующая ЦМР по детализации соответствовала масштабу 1:10 000 000. Выполните генерализацию ЦМР с использованием созданного вами инструмента Iterate Focal Statistics. Используйте размер окна, равный 5 ячейкам и подберите количество итераций такое, при котором детализация сглаженной ЦМР будет равна результату, полученному методом структурной генерализации. Создайте таблицу описательных статистик исходной и генерализованных ЦМР, включающую следующие столбцы: минимум; максимум; среднее; стандартное отклонение; Постройте по ЦМР горизонтали на следующих уровнях (можно взять то подмножество, которое релевантно для вашей области): -12000 -10000 -8000 -6000 -5000 -4500 -4000 -3500 -3000 -2500 -2000 -1500 -1000 -500 -200 -100 -50 0 50 100 150 200 300 500 750 1000 1250 1500 1750 2000 2500 3000 3500 4000 4500 5000 6000 7000 8000 9000 Отобразите три цифровые модели рельефа в единой гипсометрической шкале с вышеуказанными ступенями. Спроектируйте цветовую шкалу, на которой будут хорошо различимы указанные ступени. Добавьте объекты береговой линии, линейной и площадной гидрографии. В проекте одновремененно должны отображаться следующие слои: цифровая модель рельефа, горизонтали, береговая линия, гидрография линейная, гидрография площадная. Экспортируйте три изображения в масштабе 1:10 000 000: Исходная ЦМР Структурная генерализация Генерализация методом глобальной фильтрации Напишите отчет о проделанной работе, который включает следующие пункты: Цель и задачи Источники данных Алгоритмы генерализации (пошаговое описание). Ход выполнения работы Анализ результатов В разделе анализа результатов необходимо сравнить качество полученных ЦМР с точки зрения географического правдоподобия и точности отображения рельефа. Анализ должен опираться как на визуальное сравнение изображений, так и на рассчитанные для каждой ЦМР описательные статистики. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
